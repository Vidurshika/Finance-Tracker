1.npm create vite@latest(react and js)
2.npm install
3.remove app.css
4.empty index.css
5.components,context,hooks,pages
6.auth in pages- login,signup 
7.dashboard in pages - home,income,expense
8.utils and its 3 files
9.tailwind -  npm install tailwindcss @tailwindcss/vite 
              add plug-in and import to vite.config.js
              @import "tailwindcss"; in index.css
10.google fonts
11.index.css
12.npm i react-icons axios moment emoji-picker-react react-router-dom recharts react-hot-toast
    This will install the following packages:
    react-icons: For adding icons in your React app.
    axios: For making HTTP requests.
    moment: For working with dates and times.
    emoji-picker-react: For adding emoji pickers in your React app.
    react-router-dom: For routing in React apps
    recharts: For creating charts in React.
    react-hot-toast: For displaying toast notifications in React.
13.App.jsx
14. set Routes
15.login and auth layouts
16. About Auth layout--{children}
    *children is a special prop in React.
    *It refers to whatever JSX you wrap inside this component when you use it.
    📦 Example usage:
    *Suppose you use AuthLayout like this in your Login.js page:
    <AuthLayout>
    <p>Welcome back, please log in.</p>
    </AuthLayout>
    *Then children will be:<p>Welcome back, please log in.</p>
    *And it will be inserted at:{children}in your AuthLayout component.
    ✅ What does this mean?
    *Your layout gives a consistent outer structure (e.g., logo, styles, background), and children allows you to insert different content inside that layout.
    *This makes your layout reusable for both Login, SignUp, or any other page.

17.input component,input box (in login page)styles added to index.css
18.utils-helper:-
    *In a front-end app structure, the utils (short for utilities) folder is used to store reusable helper functions or modules that can be used throughout your application. These are not tied to a specific component or feature but provide general functionality.
    Common Uses of a utils Folder:
    Formatting Helpers e.g., formatDate.js, capitalize.js, formatCurrency.js
    Validation Functions e.g., validateEmail.js, isStrongPassword.js
    API Helpers e.g., fetchWithTimeout.js, handleApiErrors.js
    Conversion Utilities e.g., bytesToMB.js, secondsToTime.js
    Math or String Utilities e.g., roundToDecimal.js, truncateText.js

19.sign up page

after this back end started...

34. add axiosInstance.js modify apiPAths.js
35. add login api call in handleLogin , Login.jsx
36. testing -> 1 terminal for back, 2 terminal for front end

// DEV TOOLS for 35
 go to to application section -> local storage section to see token
 go to network -> select all -> then select component (url last /path = that name on the right side)-> then from top bar select headers, payload, response etc

37. sign up api call , uploadImage.js
38. Home layout and design, Dashboard layout , navbar , sidebar
39. Home-fetch dashdata , other components in the home
40. Home- barchart and piechart for exp
41. Income componet and CRUD



extra -
So anything stored via updateUser(user) ; something like useState and save user, is lost unless:
You save it in localStorage or
You re-fetch the user from the backend using the stored token.

extra -
res in the backend is what you use to send a response to the browser.
response in the frontend is what you use to receive the server’s reply.
req in back - It represents the incoming HTTP request that the frontend (or browser) sends to the backend.


extra -
You store the token in localStorage, but
You do not store the user object persistently in localStorage,
So on page reload, your context's initial state is null


extra -
What exactly happens in the backend when I POST an expense? via Postman when the front end is built, and how all get automatically updated after new expense?
* One POST request ➜ Backend saves ➜ Frontend fetches ➜ Dashboard updates.

* When a POST request comes to /expenses, run its controller-> store in db->Response Sent Back to Postman or Frontend
  ->frontend loads the dashboard again, it calls all necessary end points to fetch again->the backend calculate values by taking from db again->That updated total gets returned to the frontend → state updates → UI updates

* useEffect only fetch once, so have to reload page so the front end will re fetch again (unless front wont refetch)

* Using WebSocket / real-time DB->Re fetch->Backend pushes updates to frontend (not used yet in my app)


extra -
*utils/apiPaths = routes/end points related to backend (backend send and receive data using those url)
*front end navigate (paths) in App.jsx = routes within front end (url appears in the web browser)


extra - 
*what is the function of useState which uses T/F (like open state true / false)
*React state changes:When you call setopenAddIncomeModal(false), you’re telling React, "Set this piece of state (openAddIncomeModal) to false."
*Component re-renders:React automatically re-renders the component where the state lives (your Income component).
*Conditional rendering kicks in:Inside your Modal component, you have this:if (!isOpen) return null;
*When openAddIncomeModal is false, isOpen is false, so the Modal component returns null — meaning it renders nothing (no modal in the UI).
*Result:The modal disappears from the screen because React no longer renders it.



extra - HOW CHILDREN IS USED...
in income :-
<Modal>
    <AddIncomeForm onAddIncome={handleAddIncome}/> {/* send data to back end */}
</Modal> 
& in Modal :-
<div className="p-4 space-y-4 overflow-y-auto max-h-[70vh]"> {/* scrollable */}
    {children}
</div>
*{children} is equivalent to inserting: <AddIncomeForm onAddIncome={handleAddIncome} />



extra - 
Explanation of arrow functions
*Add two numbers	(a, b) => a + b means->	function(a, b) { return a + b; }
*(selectedIcon) => handleChange("icon", selectedIcon)
This is an arrow function that:Takes one parameter: selectedIcon and Calls another function inside: handleChange(...)


extra -
<Toast> => rendering toast notifications (those little pop-up messages you often see on websites, like “Login successful” or “Error saving data”).
* why put in App.jsx = ensures global access to toast messages throughout your entire application


extra - 
✅ What causes a React component to re-render?
A React component (like your Dashboard) will only re-render if:
                Its state changes (useState)
                Its props change (passed from a parent)
                It reads from a context (useContext) and that context value changes
                A navigation or manual refresh happens



extra - When a new income is added will the dashboard get updated ?
*Adding income does not auto-refresh the dashboard unless you've coded it to react to changes (shared state-conetxt, props, or refetching logic).


extra -
*A new income added then income page needs to be updated , so fetching is re called
But when move to Home , all are updated automatically why :-
        This useEffect means:
            useEffect(() => {
            fetchDashboardData();
            }, []);
        👉 Run the function fetchDashboardData() ONLY ONCE when this component is loaded (mounted).
*When you click to go to /dashboard, this happens:
React shows the Home.jsx component-That’s a new mount of the Dashboard-So this code runs: above useEffect
Which calls your API and gets updated data--->This is why your dashboard auto-updates and shows the latest totals even if you just added new income elsewhere

*Mounted = when the component appears (or reappears) on the screen.
In your app, that happens when you:Navigate to /dashboard using a route , Or refresh the browser while on /dashboard

extra -
*useEffect(() => {
  fetchIncomeDetails();
}, [incomeData]);
It means: Every time incomeData changes, run fetchIncomeDetails() again.So it is an infinite loop.

*seEffect(() => {
  console.log("Data changed:", data);
}, [data]);
This is totally safe because:You're not changing data inside the effect.you’re only reacting to changes 